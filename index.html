<html>

<head>

    <script src='Box2dWeb.min.js'></script>
    <script src="Three.js"></script>
    <script src="StereoEffect.js"></script>
    <script src="keyboard.js"></script>
    <script src="jquery.js"></script>
    <script src="maze.js"></script>

    <script>
        var camera = undefined,
            scene = undefined,
            renderer = undefined,
            stereoEffect = undefined,
            container = undefined,
            light = undefined,
            mouseX = undefined,
            mouseY = undefined,
            maze = undefined,
            mazeMesh = undefined,
            mazeDimension = 11,
            planeMesh = undefined,
            ballMesh = undefined,
            ballRadius = 0.25,
            keyAxis = [0, 0],
            ironTexture = THREE.ImageUtils.loadTexture('/ball.png'),
            planeTexture = THREE.ImageUtils.loadTexture('/concrete.png'),
            brickTexture = THREE.ImageUtils.loadTexture('/brick.png'),
            gameState = undefined,

            // Box2D shortcuts
            b2World = Box2D.Dynamics.b2World,
            b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
            b2BodyDef = Box2D.Dynamics.b2BodyDef,
            b2Body = Box2D.Dynamics.b2Body,
            b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
            b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
            b2Settings = Box2D.Common.b2Settings,
            b2Vec2 = Box2D.Common.Math.b2Vec2,

            // Box2D world variables 
            wWorld = undefined,
            wBall = undefined;


        function createPhysicsWorld() {
            // Create the world object.
            wWorld = new b2World(new b2Vec2(0, 0), true);

            // Create the ball.
            var bodyDef = new b2BodyDef();
            bodyDef.type = b2Body.b2_dynamicBody;
            bodyDef.position.Set(1, 1);
            wBall = wWorld.CreateBody(bodyDef);
            var fixDef = new b2FixtureDef();
            fixDef.density = 1.0;
            fixDef.friction = 0.0;
            fixDef.restitution = 0.25;
            fixDef.shape = new b2CircleShape(ballRadius);
            wBall.CreateFixture(fixDef);

            // Create the maze.
            bodyDef.type = b2Body.b2_staticBody;
            fixDef.shape = new b2PolygonShape();
            fixDef.shape.SetAsBox(0.5, 0.5);
            for (var i = 0; i < maze.dimension; i++) {
                for (var j = 0; j < maze.dimension; j++) {
                    if (maze[i][j]) {
                        bodyDef.position.x = i;
                        bodyDef.position.y = j;
                        wWorld.CreateBody(bodyDef).CreateFixture(fixDef);
                    }
                }
            }
        }


        function generate_maze_mesh(field) {
            var dummy = new THREE.Geometry();
            for (var i = 0; i < field.dimension; i++) {
                for (var j = 0; j < field.dimension; j++) {
                    if (field[i][j]) {
                        var geometry = new THREE.CubeGeometry(1, 1, 1, 1, 1, 1);
                        var mesh_ij = new THREE.Mesh(geometry);
                        mesh_ij.position.x = i;
                        mesh_ij.position.y = j;
                        mesh_ij.position.z = 0.5;
                        THREE.GeometryUtils.merge(dummy, mesh_ij);
                    }
                }
            }
            var material = new THREE.MeshPhongMaterial({
                map: brickTexture
            });
            var mesh = new THREE.Mesh(dummy, material)
            return mesh;
        }


        function createRenderWorld() {
            // Create the scene object.
            scene = new THREE.Scene();

            // Add the light.
            light = new THREE.PointLight(0xffffff, 1);
            light.position.set(mazeDimension / 2, mazeDimension / 2, mazeDimension);
            scene.add(light);

            // Add the ball.
            g = new THREE.SphereGeometry(ballRadius, 32, 16);
            m = new THREE.MeshPhongMaterial({
                map: ironTexture
            });
            ballMesh = new THREE.Mesh(g, m);
            ballMesh.position.set(1, 1, ballRadius);
            scene.add(ballMesh);

            // Add the camera.
            var aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(90.0, aspect, 0.001, 1000);
            camera.position.set((mazeDimension - 1)/2, (mazeDimension - 1)/2, mazeDimension*1.1)
//             camera.lookAt(new THREE.Vector3(mazeDimension/2, mazeDimension/2, 1))

            scene.add(camera);

            // Add the maze.
            mazeMesh = generate_maze_mesh(maze);
            scene.add(mazeMesh);

            // Add the ground.
            g = new THREE.PlaneGeometry(mazeDimension, mazeDimension, mazeDimension, mazeDimension);
            planeTexture.wrapS = planeTexture.wrapT = THREE.RepeatWrapping;
            planeTexture.repeat.set(mazeDimension, mazeDimension);
            m = new THREE.MeshPhongMaterial({
                map: planeTexture
            });
            planeMesh = new THREE.Mesh(g, m);
            planeMesh.position.set((mazeDimension - 1) / 2, (mazeDimension - 1) / 2, 0);
            planeMesh.rotation.set(Math.PI / 2, 0, 0);
            scene.add(planeMesh);

        }


        function updatePhysicsWorld() {

            // Apply "friction". 
            var lv = wBall.GetLinearVelocity();
            lv.Multiply(0.95);
            wBall.SetLinearVelocity(lv);

            // Apply user-directed force.
            var f = new b2Vec2(keyAxis[0] * wBall.GetMass() * 0.35, keyAxis[1] * wBall.GetMass() * 0.35);
            wBall.ApplyImpulse(f, wBall.GetPosition());
            keyAxis = [0, 0];

            // Take a time step.
            wWorld.Step(1 / 60, 8, 3);
        }


        function updateRenderWorld() {

            // Update ball position.
            var stepX = wBall.GetPosition().x - ballMesh.position.x;
            var stepY = wBall.GetPosition().y - ballMesh.position.y;
            ballMesh.position.x += stepX;
            ballMesh.position.y += stepY;

            // Update ball rotation.
            var tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(0, 1, 0), stepX / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            tempMat = new THREE.Matrix4();
            tempMat.makeRotationAxis(new THREE.Vector3(1, 0, 0), -stepY / ballRadius);
            tempMat.multiplySelf(ballMesh.matrix);
            ballMesh.matrix = tempMat;
            ballMesh.rotation.getRotationFromMatrix(ballMesh.matrix);

            // Update camera and light positions.
//             camera.position.x += (ballMesh.position.x - camera.position.x) * 0.1;
//             camera.position.y += (ballMesh.position.y - camera.position.y) * 0.1;
//             camera.position.z += (5 - camera.position.z) * 0.1;
//             light.position.x = camera.position.x;
//             light.position.y = camera.position.y;
//             light.position.z = camera.position.z - 3.7;
        }


        function gameLoop() {

            switch (gameState) {

                case 'initialize':
                    maze = generateSquareMaze(mazeDimension);
                    maze[mazeDimension - 1][mazeDimension - 2] = false;
                    createPhysicsWorld();
                    createRenderWorld();
                    light.intensity = 0;
                    var level = Math.floor((mazeDimension - 1) / 2 - 4);
                    gameState = 'fade in';
                    break;

                case 'fade in':
                    light.intensity += 0.1 * (1.0 - light.intensity);
                    stereoEffect.render(scene, camera);
                    if (Math.abs(light.intensity - 1.0) < 0.05) {
                        light.intensity = 1.0;
                        gameState = 'play'
                    }
                    break;

                case 'play':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    stereoEffect.render(scene, camera);

                    // Check for victory.
                    var mazeX = Math.floor(ballMesh.position.x + 0.5);
                    var mazeY = Math.floor(ballMesh.position.y + 0.5);
                    if (mazeX == mazeDimension && mazeY == mazeDimension - 2) {
                        mazeDimension += 2;
                        gameState = 'fade out';
                    }
                    break;

                case 'fade out':
                    updatePhysicsWorld();
                    updateRenderWorld();
                    light.intensity += 0.1 * (0.0 - light.intensity);
                    stereoEffect.render(scene, camera);
                    if (Math.abs(light.intensity - 0.0) < 0.1) {
                        light.intensity = 0.0;
                        renderer.render(scene, camera);
                        gameState = 'initialize'
                    }
                    break;

            }

            requestAnimationFrame(gameLoop);

        }


        function onResize() {
            var width = container.offsetWidth;
            var height = container.offsetHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            stereoEffect.setSize(width, height);
        }


        function onMoveKey(axis) {
            keyAxis = axis.slice(0);
        }

        $(document).ready(function() {
            // Create the renderer.
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            stereoEffect = new THREE.StereoEffect(renderer);
            stereoEffect.setSize(window.innerWidth, window.innerHeight);

            container = document.getElementById('stage');
            container.appendChild(renderer.domElement);

            // Bind keyboard and resize events.
            KeyboardJS.bind.axis('left', 'right', 'down', 'up', onMoveKey);
            KeyboardJS.bind.axis('h', 'l', 'j', 'k', onMoveKey);
//             $(window).resize(onResize);
            window.addEventListener('resize', onResize, false);
            renderer.domElement.addEventListener('click', fullscreen, false)

            // Set the initial game state.
            gameState = 'initialize';

            // Start the game loop.
            requestAnimationFrame(gameLoop);

        })
        
        function setOrientationControls(e) {
            if (!e.alpha) {
                return;
            }

            horizontal = 0
            vertical = 0
            
            if(e.beta < -20 && e.beta > -180)
                horizontal = -1
            if(e.beta > 20 && e.beta < 180)
                horizontal = 1
            if(90 - Math.abs(e.gamma) > 20)
                if(e.gamma < 0) vertical = 1
                else vertical = -1
            
            
            keyAxis = [horizontal,vertical]
//             console.log(keyAxis , e);
            return keyAxis

//             controls = new THREE.DeviceOrientationControls(camera, true);
//             controls.connect();
//             controls.update();
// 
//             window.removeEventListener('deviceorientation', setOrientationControls);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);

        function fullscreen() {
            if (container.requestFullscreen) {
                container.requestFullscreen();
            } else if (container.msRequestFullscreen) {
                container.msRequestFullscreen();
            } else if (container.mozRequestFullScreen) {
                container.mozRequestFullScreen();
            } else if (container.webkitRequestFullscreen) {
                container.webkitRequestFullscreen();
            }
        }
    </script>

    <style>
        body {
            background: black;
            font-family: 'Helvetica';
            overflow: hidden;
        }
        #stage {
            background-color: black;
            align: center;
        }
    </style>

</head>

<body>
<!--    <div id='level'>Level = 1</div>-->
<!--     <div id='instructions'>Tilt your head to control the ball and guide it out of the maze</div> -->
    <div id='stage'></div>
</body>

</html>
